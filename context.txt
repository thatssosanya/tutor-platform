# .env.example

```
# Since the ".env" file is gitignored, you can use the ".env.example" file to
# build a new ".env" file when you clone the repo. Keep this file up-to-date
# when you add new variables to `.env`.

# This file will be committed to version control, so make sure not to have any
# secrets in it. If you are cloning this repo, create a copy of this file named
# ".env" and populate it with your secrets.

# When adding additional environment variables, the schema in "/src/env.js"
# should be updated accordingly.

# Next Auth
# You can generate a new secret on the command line with:
# npx auth secret
# https://next-auth.js.org/configuration/options#secret
AUTH_SECRET=""

# Prisma
# https://www.prisma.io/docs/reference/database-reference/connection-urls#env
DATABASE_URL="file:./db.sqlite"

```

---

# .gitignore

```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# database
/prisma/db.sqlite
/prisma/db.sqlite-journal
db.sqlite

# next.js
/.next/
/out/
next-env.d.ts

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
# do not commit any .env files to git, except for the .env.example file. https://create.t3.gg/en/usage/env-variables#using-environment-variables
.env
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo

# idea files
.idea
```

---

# README.md

```
# Create T3 App

This is a [T3 Stack](https://create.t3.gg/) project bootstrapped with `create-t3-app`.

## What's next? How do I make an app with this?

We try to keep this project as simple as possible, so you can start with just the scaffolding we set up for you, and add additional things later when they become necessary.

If you are not familiar with the different technologies used in this project, please refer to the respective docs. If you still are in the wind, please join our [Discord](https://t3.gg/discord) and ask for help.

- [Next.js](https://nextjs.org)
- [NextAuth.js](https://next-auth.js.org)
- [Prisma](https://prisma.io)
- [Drizzle](https://orm.drizzle.team)
- [Tailwind CSS](https://tailwindcss.com)
- [tRPC](https://trpc.io)

## Learn More

To learn more about the [T3 Stack](https://create.t3.gg/), take a look at the following resources:

- [Documentation](https://create.t3.gg/)
- [Learn the T3 Stack](https://create.t3.gg/en/faq#what-learning-resources-are-currently-available) — Check out these awesome tutorials

You can check out the [create-t3-app GitHub repository](https://github.com/t3-oss/create-t3-app) — your feedback and contributions are welcome!

## How do I deploy this?

Follow our deployment guides for [Vercel](https://create.t3.gg/en/deployment/vercel), [Netlify](https://create.t3.gg/en/deployment/netlify) and [Docker](https://create.t3.gg/en/deployment/docker) for more information.

```

---

# context.txt

```

```

---

# eslint.config.js

```
import { dirname } from "path"
import { fileURLToPath } from "url"
import { FlatCompat } from "@eslint/eslintrc"

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const compat = new FlatCompat({
  baseDirectory: __dirname,
})

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
]

export default eslintConfig

```

---

# next.config.js

```
/**
 * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially useful
 * for Docker builds.
 */
import { fileURLToPath } from "node:url"
import { createJiti } from "jiti"
const jiti = createJiti(fileURLToPath(import.meta.url))
jiti.import("./src/env")

/** @type {import("next").NextConfig} */
const config = {
  reactStrictMode: true,

  i18n: {
    locales: ["ru"],
    defaultLocale: "ru",
  },
  transpilePackages: ["next-auth"],
}

export default config

```

---

# package.json

```
{
  "name": "tutor-platform",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "next build",
    "check": "next lint && tsc --noEmit",
    "db:generate": "prisma migrate dev",
    "db:migrate": "prisma migrate deploy",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "dev": "next dev --turbo",
    "format:check": "prettier --check \"**/*.{ts,tsx,js,jsx,mdx}\" --cache",
    "format:write": "prettier --write \"**/*.{ts,tsx,js,jsx,mdx}\" --cache",
    "postinstall": "prisma generate",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "preview": "next build && next start",
    "start": "next start",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.7.2",
    "@headlessui/react": "^2.2.7",
    "@prisma/client": "^6.5.0",
    "@t3-oss/env-nextjs": "^0.12.0",
    "@tanstack/react-query": "^5.69.0",
    "@trpc/client": "^11.0.0",
    "@trpc/next": "^11.0.0",
    "@trpc/react-query": "^11.0.0",
    "@trpc/server": "^11.0.0",
    "bcryptjs": "^3.0.2",
    "cheerio": "^1.1.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "install": "^0.13.0",
    "jiti": "^2.5.1",
    "lucide-react": "^0.542.0",
    "mathml-to-latex": "^1.5.0",
    "next": "^15.2.3",
    "next-auth": "5.0.0-beta.25",
    "npm": "^11.6.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "superjson": "^2.2.1",
    "tailwind-merge": "^3.3.1",
    "undici": "^7.15.0",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@tailwindcss/postcss": "^4.0.15",
    "@types/node": "^20.14.10",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "eslint": "^9.23.0",
    "eslint-config-next": "^15.2.3",
    "postcss": "^8.5.3",
    "prettier": "^3.5.3",
    "prettier-plugin-tailwindcss": "^0.6.11",
    "prisma": "^6.5.0",
    "tailwindcss": "^4.0.15",
    "typescript": "^5.8.2",
    "typescript-eslint": "^8.27.0"
  },
  "ct3aMetadata": {
    "initVersion": "7.39.3"
  },
  "packageManager": "npm@11.4.2"
}

```

---

# postcss.config.js

```
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

```

---

# prisma/schema.prisma

```
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = env("DATABASE_URL")
}

enum QuestionSource {
    FIPI
    AI
    USER
}

enum SolutionType {
    SHORT
    LONG
    MULTICHOICE
    MULTIRESPONSE
    MULTICHOICEGROUP
}

model User {
    id String @id @unique @default(cuid())

    name        String
    displayName String?
    password    String
    permissions Int

    creatorId String?
    creator   User?   @relation("CreatedBy", fields: [creatorId], references: [id])
    students  User[]  @relation("CreatedBy")

    createdQuestions Question[]
    createdTests     Test[]

    assignmentsGiven    Assignment[] @relation("AssignedBy")
    assignmentsReceived Assignment[] @relation("AssignedTo")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Subject {
    id String @id @unique @default(cuid())

    name String

    topics Question[]
    Topic  Topic[]
    Test   Test[]
}

model Topic {
    id String @id @default(cuid())

    name String

    subjectId String
    subject   Subject @relation(fields: [subjectId], references: [id])

    parentId String?
    parent   Topic?  @relation("TopicHierarchy", fields: [parentId], references: [id])
    children Topic[] @relation("TopicHierarchy")

    questions Question[]

    @@unique([id, subjectId])
}

model Question {
    id String @id @unique @default(cuid())

    name            String
    prompt          String
    body            String?
    solutionPostfix String?
    work            String?
    solution        String?
    solutionType    SolutionType
    source          QuestionSource @default(FIPI)

    creatorId String?
    creator   User?   @relation(fields: [creatorId], references: [id])

    subjectId String
    subject   Subject @relation(fields: [subjectId], references: [id])

    topics Topic[]

    attachments Attachment[]
    options     Option[]

    testEntries    TestQuestion[]
    studentAnswers StudentAnswer[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Attachment {
    id String @id @unique @default(cuid())

    url String

    questionId String
    question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model Option {
    id String @id @unique @default(cuid())

    body String

    questionId String
    question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model Test {
    id String @id @default(cuid())

    name String

    creatorId String
    creator   User   @relation(fields: [creatorId], references: [id])

    subjectId String
    subject   Subject @relation(fields: [subjectId], references: [id])

    questions TestQuestion[]

    assignments Assignment[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model TestQuestion {
    id String @id @default(cuid())

    order Float

    testId     String
    test       Test     @relation(fields: [testId], references: [id], onDelete: Cascade)
    questionId String
    question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

    @@unique([testId, questionId])
    @@unique([testId, order])
}

model Assignment {
    id String @id @default(cuid())

    dueAt       DateTime?
    completedAt DateTime?

    testId String
    test   Test   @relation(fields: [testId], references: [id])

    assignedById String
    assignedBy   User   @relation("AssignedBy", fields: [assignedById], references: [id])
    assignedToId String
    assignedTo   User   @relation("AssignedTo", fields: [assignedToId], references: [id])

    answers StudentAnswer[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model StudentAnswer {
    id String @id @default(cuid())

    answer String

    assignmentId String
    assignment   Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
    questionId   String
    question     Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([assignmentId, questionId])
}

```

---

# src/app/api/auth/[...nextauth]/route.ts

```
import { handlers } from "@/server/auth";

export const { GET, POST } = handlers;

```

---

# src/components/QuestionCard.tsx

```
import React from "react"

import { Paper, Row, Stack } from "@/ui"
import { type RouterOutputs } from "@/utils/api"

type Question = RouterOutputs["question"]["getPaginated"]["items"][number]

type QuestionCardProps = {
  question: Question
  controls: (questionId: string) => React.ReactNode
}

export function QuestionCard({ question, controls }: QuestionCardProps) {
  return (
    <Paper data-id={question.id}>
      <Row className="items-start justify-between gap-4">
        <Stack className="flex-1">
          <p className="text-sm font-semibold text-primary">
            {question.prompt}
          </p>
          <p className="mt-1 line-clamp-2 text-sm text-secondary">
            {question.body}
          </p>
        </Stack>
        <div className="flex-shrink-0">{controls(question.id)}</div>
      </Row>
    </Paper>
  )
}

```

---

# src/components/QuestionsView.tsx

```
import React, { useMemo } from "react"

import { Button, Stack } from "@/ui"
import { api } from "@/utils/api"

import { QuestionCard } from "./QuestionCard"

type QuestionsViewProps = {
  subjectId: string
  testId: string
  cardControls: (questionId: string) => React.ReactNode
}

export function QuestionsView({
  subjectId,
  testId,
  cardControls,
}: QuestionsViewProps) {
  const testQuery = api.test.getById.useQuery({ id: testId })
  const questionsQuery = api.question.getPaginated.useInfiniteQuery(
    { subjectId, limit: 10 },
    { getNextPageParam: (lastPage) => lastPage.nextCursor }
  )

  if (questionsQuery.isLoading || testQuery.isLoading) {
    return <p>Загрузка вопросов...</p>
  }

  if (!questionsQuery.data?.pages.length) {
    return <p>Вопросы по этому предмету не найдены.</p>
  }

  return (
    <Stack className="gap-4">
      {questionsQuery.data.pages.map((page, i) => (
        <React.Fragment key={i}>
          {page.items.map((question) => (
            <QuestionCard
              key={question.id}
              question={question}
              controls={cardControls}
            />
          ))}
        </React.Fragment>
      ))}

      {questionsQuery.hasNextPage && (
        <Button
          variant="secondary"
          onClick={() => questionsQuery.fetchNextPage()}
          disabled={questionsQuery.isFetchingNextPage}
        >
          {questionsQuery.isFetchingNextPage ? "Загрузка..." : "Загрузить ещё"}
        </Button>
      )}
    </Stack>
  )
}

```

---

# src/components/QuestionsViewFilters.tsx

```
import React from "react"

export function QuestionViewFilters() {
  return <>Тут какие-то фильтры</>
}

```

---

# src/components/TestCard.tsx

```
import { FilePen, Trash2, UserPlus } from "lucide-react"
import React from "react"

import { Paper, Row, Stack } from "@/ui"
import { type RouterOutputs } from "@/utils/api"

type Test = RouterOutputs["test"]["getAllBySubject"][number]

type TestCardProps = {
  test: Test
  controls: (testId: string) => React.ReactNode
}

export function TestCard({ test, controls }: TestCardProps) {
  return (
    <Paper data-id={test.id}>
      <Row className="items-center justify-between">
        <Stack>
          <h3 className="font-semibold text-primary">{test.name}</h3>
          <p className="text-sm text-secondary">
            {test._count.questions} вопросов
          </p>
        </Stack>
        <Row className="gap-2">{controls(test.id)}</Row>
      </Row>
    </Paper>
  )
}

```

---

# src/components/TestsView.tsx

```
import { Plus, X } from "lucide-react"
import React, { useState } from "react"

import { Box, Button, Input, Paper, Row, Stack } from "@/ui"
import { api } from "@/utils/api"

import { TestCard } from "./TestCard"

type TestsViewProps = {
  subjectId: string
  cardControls: (testId: string) => React.ReactNode
  isCreateAllowed?: boolean
}

export function TestsView({
  subjectId,
  cardControls,
  isCreateAllowed = false,
}: TestsViewProps) {
  const [isCreating, setIsCreating] = useState(false)
  const [newTestName, setNewTestName] = useState("")

  const utils = api.useUtils()
  const testsQuery = api.test.getAllBySubject.useQuery({ subjectId })
  const createTestMutation = api.test.create.useMutation({
    onSuccess: async () => {
      await utils.test.getAllBySubject.invalidate({ subjectId })
      setIsCreating(false)
      setNewTestName("")
    },
  })

  const handleCancel = () => {
    setIsCreating(false)
    setNewTestName("")
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!newTestName.trim()) return

    createTestMutation.mutate({
      name: newTestName,
      subjectId: subjectId,
    })
  }

  if (testsQuery.isLoading) return <p>Загрузка тестов...</p>

  const noTestsFound = !testsQuery.data || testsQuery.data.length === 0

  return (
    <Stack className="gap-4">
      {!noTestsFound &&
        testsQuery.data.map((test) => (
          <TestCard key={test.id} test={test} controls={cardControls} />
        ))}

      {noTestsFound && <p>Тесты по этому предмету не найдены.</p>}

      {isCreateAllowed && (
        <div className="mt-2">
          {isCreating ? (
            <Paper>
              <form>
                <Row className="gap-4">
                  <Input
                    placeholder="Название нового теста"
                    value={newTestName}
                    onChange={(e) => setNewTestName(e.target.value)}
                    autoFocus
                  />
                  <Button
                    type="submit"
                    onClick={handleSubmit}
                    disabled={createTestMutation.isPending}
                  >
                    Создать
                  </Button>
                  <Button variant="danger" type="button" onClick={handleCancel}>
                    <X className="h-4 w-4" />
                  </Button>
                </Row>
              </form>
            </Paper>
          ) : (
            <Button variant="secondary" onClick={() => setIsCreating(true)}>
              <Plus className="mr-2 h-4 w-4" />
              Добавить тест
            </Button>
          )}
        </div>
      )}
    </Stack>
  )
}

```

---

# src/components/TestsViewFilters.tsx

```
import React, { useEffect, useMemo } from "react"

import { RadioGroup, type RadioOption } from "@/ui"
import { api } from "@/utils/api"

type TestsViewFiltersProps = {
  selectedSubjectId: string | null
  onSelectedSubjectIdChange: (id: string) => void
}

export function TestsViewFilters({
  selectedSubjectId,
  onSelectedSubjectIdChange,
}: TestsViewFiltersProps) {
  const subjectsQuery = api.subject.getAll.useQuery()

  const firstSubjectId = useMemo(
    () =>
      (subjectsQuery.data &&
        subjectsQuery.data.length > 0 &&
        subjectsQuery.data[0]!.id) ||
      null,
    [subjectsQuery.data]
  )

  useEffect(() => {
    if (!selectedSubjectId && firstSubjectId) {
      onSelectedSubjectIdChange(firstSubjectId)
    }
  }, [selectedSubjectId, firstSubjectId, onSelectedSubjectIdChange])

  if (subjectsQuery.isLoading) return <p>Загрузка предметов...</p>
  if (!subjectsQuery.data || subjectsQuery.data.length === 0)
    return <p>Предметы не найдены.</p>

  const subjectOptions: RadioOption<string>[] = subjectsQuery.data.map(
    (subject) => ({
      value: subject.id,
      label: subject.name,
    })
  )

  return (
    <RadioGroup<string>
      options={subjectOptions}
      value={selectedSubjectId}
      onChange={onSelectedSubjectIdChange}
      variant="button"
    />
  )
}

```

---

# src/env.ts

```
import { createEnv } from "@t3-oss/env-nextjs"
import { z } from "zod"

export const env = createEnv({
  /**
   * Specify your server-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars.
   */
  server: {
    AUTH_SECRET: z.string(),
    DATABASE_URL: z.string().url(),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),
    FIPI_INTERMEDIATE_CERT: z.string(),
  },

  /**
   * Specify your client-side environment variables schema here. This way you can ensure the app
   * isn't built with invalid env vars. To expose them to the client, prefix them with
   * `NEXT_PUBLIC_`.
   */
  client: {
    // NEXT_PUBLIC_CLIENTVAR: z.string(),
  },

  /**
   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.
   * middlewares) or client-side so we need to destruct manually.
   */
  runtimeEnv: {
    AUTH_SECRET: process.env.AUTH_SECRET,
    DATABASE_URL: process.env.DATABASE_URL,
    NODE_ENV: process.env.NODE_ENV,
    FIPI_INTERMEDIATE_CERT: process.env.FIPI_INTERMEDIATE_CERT,
  },
  /**
   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially
   * useful for Docker builds.
   */
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  /**
   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and
   * `SOME_VAR=''` will throw an error.
   */
  emptyStringAsUndefined: true,
})

```

---

# src/layouts/DefaultLayout.tsx

```
import React from "react"

interface DefaultLayoutProps {
  children: React.ReactNode
}

const DefaultLayout: React.FC<DefaultLayoutProps> = ({ children }) => {
  return (
    <div className="relative flex flex-col items-center bg-primary min-h-screen p-4 md:p-8">
      {children}
    </div>
  )
}

export default DefaultLayout

```

---

# src/pages/_app.tsx

```
import { type Session } from "next-auth"
import { SessionProvider } from "next-auth/react"
import { type AppType } from "next/app"
import { Geist } from "next/font/google"

import { api } from "@/utils/api"

import "@/styles/globals.css"

const geist = Geist({
  subsets: ["latin"],
})

const MyApp: AppType<{ session: Session | null }> = ({
  Component,
  pageProps: { session, ...pageProps },
}) => {
  return (
    <SessionProvider session={session}>
      <div className={geist.className}>
        <Component {...pageProps} />
      </div>
    </SessionProvider>
  )
}

export default api.withTRPC(MyApp)

```

---

# src/pages/admin/scrape/subjects/[subjectId].tsx

```
import type { NextPage } from "next"
import { useRouter } from "next/router"
import { useEffect, useState, Fragment } from "react"
import { api } from "@/utils/api"

const ScrapeSubjectPage: NextPage = () => {
  const router = useRouter()
  const { subjectId } = router.query
  const fipiSubjectId = subjectId as string

  const [page, setPage] = useState(1)
  const apiUtils = api.useUtils()

  const { data: subject, isLoading: isLoadingSubject } =
    api.subject.getById.useQuery(
      { id: fipiSubjectId },
      { enabled: !!fipiSubjectId }
    )

  const { data: topics, isLoading: isLoadingTopics } =
    api.topic.getBySubjectId.useQuery(
      { subjectId: fipiSubjectId },
      { enabled: !!fipiSubjectId }
    )

  const { data: totalPages } = api.question.getPageCount.useQuery(
    { subjectId: fipiSubjectId },
    { enabled: !!fipiSubjectId && !!topics && topics.length > 0 }
  )

  const { data: questions, isLoading: isLoadingQuestions } =
    api.question.getBySubjectPaginated.useQuery(
      { subjectId: fipiSubjectId, page },
      { enabled: !!fipiSubjectId && !!topics && topics.length > 0 }
    )

  useEffect(() => {
    setPage(1)
  }, [fipiSubjectId])

  const scrapeTopicsMutation = api.scraper.scrapeTopics.useMutation({
    onSuccess: () => {
      void apiUtils.topic.getBySubjectId.invalidate()
    },
  })

  const scrapePageMutation = api.scraper.scrapePage.useMutation({
    onSuccess: () => {
      void apiUtils.question.invalidate()
    },
  })

  const handleScrapeTopics = () => {
    if (!fipiSubjectId) return
    scrapeTopicsMutation.mutate({ subjectId: fipiSubjectId })
  }

  const handleScrapeQuestions = () => {
    if (!fipiSubjectId) return
    scrapePageMutation.mutate({ subjectId: fipiSubjectId, page })
  }

  if (!router.isReady || isLoadingSubject) {
    return <div>Loading...</div>
  }

  if (!subject) {
    return (
      <div>
        Subject with ID {fipiSubjectId} not found. Go back to the subjects list
        to create it.
      </div>
    )
  }

  const paginationButtons = Array.from(
    { length: (totalPages ?? 0) + 1 },
    (_, i) => i + 1
  )

  return (
    <div style={{ padding: "2rem", fontFamily: "sans-serif" }}>
      <h1>
        Scraping for: {subject.name} ({subject.id})
      </h1>

      {isLoadingTopics && <p>Loading topics...</p>}

      {!isLoadingTopics && (!topics || topics.length === 0) && (
        <div>
          <p>No topics found for this subject.</p>
          <button
            onClick={handleScrapeTopics}
            disabled={scrapeTopicsMutation.isPending}
          >
            {scrapeTopicsMutation.isPending
              ? "Scraping Topics..."
              : "Scrape Topics"}
          </button>
        </div>
      )}

      {topics && topics.length > 0 && (
        <Fragment>
          <div style={{ margin: "1rem 0" }}>
            {paginationButtons.map((p) => (
              <button
                key={p}
                onClick={() => setPage(p)}
                style={{
                  fontWeight: p === page ? "bold" : "normal",
                  margin: "0 0.25rem",
                }}
              >
                {p}
              </button>
            ))}
          </div>

          <h2>Page {page}</h2>

          {isLoadingQuestions && <p>Loading questions...</p>}

          {!isLoadingQuestions && (!questions || questions.length === 0) && (
            <div>
              <p>No questions found in the database for this page.</p>
              <button
                onClick={handleScrapeQuestions}
                disabled={scrapePageMutation.isPending}
              >
                {scrapePageMutation.isPending
                  ? `Scraping Page ${page}...`
                  : `Start Scrape for Page ${page}`}
              </button>
            </div>
          )}

          {questions && questions.length > 0 && (
            <ul>
              {questions.map((q) => (
                <li key={q.id} style={{ margin: "1rem 0" }}>
                  <strong>{q.name}</strong>
                  <p style={{ whiteSpace: "pre-wrap" }}>{q.body}</p>
                </li>
              ))}
            </ul>
          )}
        </Fragment>
      )}
    </div>
  )
}

export default ScrapeSubjectPage

```

---

# src/pages/admin/scrape/subjects/index.tsx

```
import type { NextPage } from "next"
import Link from "next/link"
import { api } from "@/utils/api"

const SubjectsPage: NextPage = () => {
  const apiUtils = api.useUtils()
  const { data: subjects, isLoading } = api.subject.getAll.useQuery()
  const scrapeSubjectsMutation = api.scraper.scrapeSubjects.useMutation({
    onSuccess: () => {
      void apiUtils.subject.getAll.invalidate()
    },
  })

  const handleScrapeSubjects = () => {
    scrapeSubjectsMutation.mutate()
  }

  if (isLoading) {
    return <div>Loading subjects...</div>
  }

  return (
    <div style={{ padding: "2rem", fontFamily: "sans-serif" }}>
      <h1>Subjects</h1>
      {subjects && subjects.length > 0 ? (
        <ul>
          {subjects.map((subject) => (
            <li key={subject.id}>
              <Link href={`/admin/scrape/subjects/${subject.id}`}>
                {subject.name}
              </Link>
            </li>
          ))}
        </ul>
      ) : (
        <div>
          <p>No subjects found in the database.</p>
          <button
            onClick={handleScrapeSubjects}
            disabled={scrapeSubjectsMutation.isPending}
          >
            {scrapeSubjectsMutation.isPending
              ? "Scraping..."
              : "Scrape Subjects from FIPI"}
          </button>
        </div>
      )}
    </div>
  )
}

export default SubjectsPage

```

---

# src/pages/api/auth/signup.ts

```
import type { NextApiRequest, NextApiResponse } from "next"
import bcrypt from "bcryptjs"

import { db } from "@/server/db"

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Метод не разрешен" })
  }

  try {
    const { name, password } = req.body

    if (
      !name ||
      !password ||
      typeof password !== "string" ||
      password.length < 6
    ) {
      return res.status(400).json({
        message:
          "Неверные данные: пароль должен содержать не менее 6 символов.",
      })
    }

    const existingUser = await db.user.findFirst({
      where: { name: name as string },
    })

    if (existingUser) {
      return res
        .status(422)
        .json({ message: "Пользователь с таким логином уже существует!" })
    }

    const hashedPassword = await bcrypt.hash(password, 12)

    await db.user.create({
      data: {
        name: name as string,
        password: hashedPassword,
        permissions: 0,
      },
    })

    res.status(201).json({ message: "Пользователь успешно создан!" })
  } catch (error) {
    res.status(500).json({ message: "Что-то пошло не так." })
  }
}

```

---

# src/pages/api/trpc/[trpc].ts

```
import { createNextApiHandler } from "@trpc/server/adapters/next";

import { env } from "@/env";
import { appRouter } from "@/server/api/root";
import { createTRPCContext } from "@/server/api/trpc";

// export API handler
export default createNextApiHandler({
  router: appRouter,
  createContext: createTRPCContext,
  onError:
    env.NODE_ENV === "development"
      ? ({ path, error }) => {
          console.error(
            `❌ tRPC failed on ${path ?? "<no-path>"}: ${error.message}`,
          );
        }
      : undefined,
});

```

---

# src/pages/index.tsx

```
import { signOut, useSession } from "next-auth/react"
import Head from "next/head"
import Link from "next/link"

import { Button, Container, Paper, Stack } from "@/ui"
import DefaultLayout from "@/layouts/DefaultLayout"

export default function Home() {
  const { data: session, status } = useSession()

  return (
    <>
      <Head>
        <title>Tutor Platform</title>
      </Head>
      <DefaultLayout>
        <Container className="my-auto md:max-w-md">
          <Paper>
            <Stack className="items-center gap-4 text-center">
              <h1 className="text-2xl font-bold text-primary mb-4">
                Tutor Platform
              </h1>

              {status === "loading" && (
                <p className="text-secondary">Загрузка...</p>
              )}

              {status === "authenticated" && session && (
                <Stack className="gap-2">
                  <p className="text-secondary">
                    Вы вошли как {session.user?.name}
                  </p>
                  <Button variant="danger" onClick={() => void signOut()}>
                    Выйти
                  </Button>
                </Stack>
              )}

              {status === "unauthenticated" && (
                <Stack className="gap-2">
                  <p className="text-secondary">Вы не авторизованы</p>
                  <Link href="/sign-in">
                    <Button>Войти</Button>
                  </Link>
                </Stack>
              )}
            </Stack>
          </Paper>
        </Container>
      </DefaultLayout>
    </>
  )
}

```

---

# src/pages/sign-in.tsx

```
import { useState } from "react"
import { signIn, useSession } from "next-auth/react"
import { useRouter } from "next/router"
import Head from "next/head"

import { Button, Container, Input, Paper, Row, Stack } from "@/ui"
import DefaultLayout from "@/layouts/DefaultLayout"

export default function SignInPage() {
  const [name, setName] = useState("")
  const [password, setPassword] = useState("")
  const [error, setError] = useState("")
  const [message, setMessage] = useState("")
  const router = useRouter()
  const { status } = useSession()

  if (status === "authenticated") {
    void router.push("/")
    return null
  }

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault()
    setError("")
    setMessage("")

    const result = await signIn("credentials", {
      redirect: false,
      name,
      password,
    })

    if (result?.error) {
      setError("Неверный логин или пароль")
    } else if (result?.ok) {
      void router.push("/")
    }
  }

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault()
    setError("")
    setMessage("")

    const response = await fetch("/api/auth/signup", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ name, password }),
    })

    const data = await response.json()

    if (!response.ok) {
      setError(data.message || "Что-то пошло не так.")
    } else {
      setMessage(data.message || "Успешно!")
      setName("")
      setPassword("")
    }
  }

  return (
    <>
      <Head>
        <title>Вход</title>
      </Head>
      <DefaultLayout>
        <Container className="my-auto md:max-w-md">
          <Paper>
            <form>
              <Stack className="gap-6">
                <Stack className="gap-2 text-center">
                  <h1 className="text-2xl font-semibold tracking-tight text-primary">
                    Вход или регистрация
                  </h1>
                  <p className="text-sm text-secondary">
                    Введите свои данные, чтобы продолжить
                  </p>
                </Stack>

                <Stack className="gap-4">
                  <Stack className="gap-1.5">
                    <label htmlFor="name" className="text-sm font-medium">
                      Логин
                    </label>
                    <Input
                      id="name"
                      placeholder="Логин"
                      type="text"
                      value={name}
                      onChange={(e) => setName(e.target.value)}
                      required
                    />
                  </Stack>
                  <Stack className="gap-1.5">
                    <label htmlFor="password" className="text-sm font-medium">
                      Пароль
                    </label>
                    <Input
                      id="password"
                      placeholder="Пароль"
                      type="password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </Stack>
                </Stack>

                {error && <p className="text-sm text-red-500">{error}</p>}
                {message && <p className="text-sm text-green-500">{message}</p>}

                <Row className="gap-2">
                  <Button
                    type="submit"
                    onClick={handleSignIn}
                    className="w-full"
                  >
                    Войти
                  </Button>
                  <Button
                    type="button"
                    variant="secondary"
                    onClick={handleSignUp}
                    className="w-full"
                  >
                    Зарегистрироваться
                  </Button>
                </Row>
              </Stack>
            </form>
          </Paper>
        </Container>
      </DefaultLayout>
    </>
  )
}

```

---

# src/pages/tutor/tests.tsx

```
import { FilePen, Minus, Plus, Trash2, UserPlus, X } from "lucide-react"
import Head from "next/head"
import React, { useEffect, useState } from "react"

import { QuestionViewFilters } from "@/components/QuestionsViewFilters"
import { QuestionsView } from "@/components/QuestionsView"
import { TestsView } from "@/components/TestsView"
import { TestsViewFilters } from "@/components/TestsViewFilters"
import DefaultLayout from "@/layouts/DefaultLayout"
import { Button, Container, Dialog, Stack } from "@/ui"
import { api } from "@/utils/api"

export default function TutorTestsPage() {
  const [selectedSubjectId, setSelectedSubjectId] = useState<string | null>(
    null
  )
  const [isAssignDialogOpen, setAssignDialogOpen] = useState(false)
  const [isQuestionsDialogOpen, setQuestionsDialogOpen] = useState(false)
  const [activeTestId, setActiveTestId] = useState<string | null>(null)
  const [editedQuestionIds, setEditedQuestionIds] = useState<Set<string>>(
    new Set()
  )

  const utils = api.useUtils()

  // Queries
  const activeTestQuery = api.test.getById.useQuery(
    { id: activeTestId! },
    { enabled: !!activeTestId }
  )

  // Effects
  useEffect(() => {
    if (activeTestQuery.data) {
      setEditedQuestionIds(
        new Set(activeTestQuery.data.questions.map((q) => q.questionId))
      )
    }
  }, [activeTestQuery.data])

  // Mutations
  const deleteTestMutation = api.test.delete.useMutation({
    onSuccess: () => utils.test.getAllBySubject.invalidate(),
  })
  const updateQuestionsMutation = api.test.updateQuestions.useMutation({
    onSuccess: () => {
      utils.test.getById.invalidate({ id: activeTestId! })
      utils.test.getAllBySubject.invalidate()
    },
  })

  // Handlers
  const openDialog = (
    dialogSetter: React.Dispatch<React.SetStateAction<boolean>>,
    testId: string
  ) => {
    setActiveTestId(testId)
    dialogSetter(true)
  }

  const handleDelete = (testId: string) => {
    if (window.confirm("Вы уверены, что хотите удалить этот тест?")) {
      deleteTestMutation.mutate({ id: testId })
    }
  }

  const handleToggleQuestion = (questionId: string) => {
    setEditedQuestionIds((prev) => {
      const newIds = new Set(prev)
      if (newIds.has(questionId)) {
        newIds.delete(questionId)
      } else {
        newIds.add(questionId)
      }
      return newIds
    })
  }

  const handleSaveQuestions = () => {
    if (!activeTestId) return
    updateQuestionsMutation.mutate({
      testId: activeTestId,
      questionIds: Array.from(editedQuestionIds),
    })
    setQuestionsDialogOpen(false)
  }

  // Render Props
  const testCardControls = (testId: string) => (
    <>
      <Button
        size="sm"
        variant="secondary"
        onClick={() => openDialog(setAssignDialogOpen, testId)}
      >
        <UserPlus className="h-4 w-4" />
      </Button>
      <Button
        size="sm"
        variant="secondary"
        onClick={() => openDialog(setQuestionsDialogOpen, testId)}
      >
        <FilePen className="h-4 w-4" />
      </Button>
      <Button
        size="sm"
        variant="secondary"
        onClick={() => handleDelete(testId)}
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    </>
  )

  const questionCardControls = (questionId: string) =>
    editedQuestionIds.has(questionId) ? (
      <Button
        size="sm"
        variant="danger"
        onClick={() => handleToggleQuestion(questionId)}
      >
        <X className="h-4 w-4" />
      </Button>
    ) : (
      <Button size="sm" onClick={() => handleToggleQuestion(questionId)}>
        <Plus className="h-4 w-4" />
      </Button>
    )

  return (
    <>
      <Head>
        <title>Управление тестами</title>
      </Head>
      <DefaultLayout>
        <Container>
          <div className="grid grid-cols-1 gap-8 md:grid-cols-4">
            <div className="md:col-span-1">
              <Stack className="gap-8">
                <Stack>
                  <h1 className="text-2xl font-bold">Тесты</h1>
                  <p className="mt-1 text-secondary">
                    Управляйте вашими тестами и заданиями.
                  </p>
                </Stack>
                <TestsViewFilters
                  selectedSubjectId={selectedSubjectId}
                  onSelectedSubjectIdChange={setSelectedSubjectId}
                />
              </Stack>
            </div>
            <div className="md:col-span-3">
              {selectedSubjectId ? (
                <TestsView
                  subjectId={selectedSubjectId}
                  cardControls={testCardControls}
                  isCreateAllowed={true}
                />
              ) : (
                <p className="text-secondary">
                  Выберите предмет для просмотра тестов.
                </p>
              )}
            </div>
          </div>
        </Container>
      </DefaultLayout>

      <Dialog
        isOpen={isAssignDialogOpen}
        onClose={() => setAssignDialogOpen(false)}
        title="Назначить тест"
        className="bg-primary shadow-2xl md:container"
      >
        <p>Здесь будет форма назначения теста ID: {activeTestId}.</p>
      </Dialog>

      <Dialog
        isOpen={isQuestionsDialogOpen}
        onClose={handleSaveQuestions}
        title="Выберите вопросы"
        className="bg-primary shadow-2xl md:container"
      >
        {activeTestQuery.data ? (
          <div className="mt-6 grid grid-cols-1 gap-8 md:grid-cols-3">
            <div className="md:col-span-1">
              <QuestionViewFilters />
            </div>
            <div className="md:col-span-2">
              <QuestionsView
                subjectId={activeTestQuery.data.subjectId}
                testId={activeTestQuery.data.id}
                cardControls={questionCardControls}
              />
            </div>
          </div>
        ) : (
          <p>Загрузка данных теста...</p>
        )}
      </Dialog>
    </>
  )
}

```

---

# src/server/api/root.ts

```
import { createTRPCRouter } from "@/server/api/trpc"
import { scraperRouter } from "@/server/api/routers/scraper"
import { topicRouter } from "./routers/topic"
import { questionRouter } from "./routers/question"
import { subjectRouter } from "./routers/subject"
import { testRouter } from "./routers/test"
import { assignmentRouter } from "./routers/assignment"

export const appRouter = createTRPCRouter({
  scraper: scraperRouter,
  subject: subjectRouter,
  topic: topicRouter,
  question: questionRouter,
  test: testRouter,
  assignment: assignmentRouter,
})

export type AppRouter = typeof appRouter

```

---

# src/server/api/routers/assignment.ts

```
import { z } from "zod"

import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc"
import { TRPCError } from "@trpc/server"

export const assignmentRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      z.object({
        testId: z.string(),
        assignedToId: z.string(),
        dueAt: z.date().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.assignment.create({
        data: {
          testId: input.testId,
          assignedToId: input.assignedToId,
          assignedById: ctx.session.user.id,
          dueAt: input.dueAt,
        },
      })
    }),

  getStudentAssignments: protectedProcedure.query(({ ctx }) => {
    return ctx.db.assignment.findMany({
      where: { assignedToId: ctx.session.user.id },
      orderBy: { createdAt: "desc" },
      include: { test: { select: { name: true, subject: true } } },
    })
  }),

  submitAnswers: protectedProcedure
    .input(
      z.object({
        assignmentId: z.string(),
        answers: z.array(
          z.object({
            questionId: z.string(),
            answer: z.string(),
          })
        ),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const assignment = await ctx.db.assignment.findFirst({
        where: {
          id: input.assignmentId,
          assignedToId: ctx.session.user.id,
        },
      })

      if (!assignment) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Задание не найдено.",
        })
      }

      if (assignment.completedAt) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Задание уже было выполнено.",
        })
      }

      return ctx.db.$transaction(async (prisma) => {
        await prisma.studentAnswer.createMany({
          data: input.answers.map((a) => ({
            assignmentId: input.assignmentId,
            questionId: a.questionId,
            answer: a.answer,
          })),
        })

        return prisma.assignment.update({
          where: { id: input.assignmentId },
          data: { completedAt: new Date() },
        })
      })
    }),
})

```

---

# src/server/api/routers/question.ts

```
import { z } from "zod"
import { QuestionSource, SolutionType } from "@prisma/client"

import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@/server/api/trpc"

const questionInputSchema = z.object({
  name: z.string().min(1),
  prompt: z.string(),
  body: z.string().optional(),
  solutionPostfix: z.string().optional(),
  work: z.string().optional(),
  solution: z.string().optional(),
  solutionType: z.nativeEnum(SolutionType),
  source: z.nativeEnum(QuestionSource).default("USER"),
  subjectId: z.string(),
  topicIds: z.array(z.string()),
})

export const questionRouter = createTRPCRouter({
  create: protectedProcedure
    .input(questionInputSchema)
    .mutation(async ({ ctx, input }) => {
      return ctx.db.question.create({
        data: {
          ...input,
          creatorId: ctx.session.user.id,
          topics: {
            connect: input.topicIds.map((id) => ({
              id_subjectId: { id, subjectId: input.subjectId },
            })),
          },
        },
      })
    }),

  getById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(({ ctx, input }) => {
      return ctx.db.question.findUnique({
        where: { id: input.id },
        include: { topics: true, attachments: true, options: true },
      })
    }),

  getPaginated: publicProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).nullish(),
        cursor: z.string().nullish(),
        subjectId: z.string().optional(),
        topicIds: z.array(z.string()).optional(),
        source: z.nativeEnum(QuestionSource).optional(),
      })
    )
    .query(async ({ ctx, input }) => {
      const limit = input.limit ?? 10
      const { cursor } = input

      const items = await ctx.db.question.findMany({
        take: limit + 1,
        where: {
          subjectId: input.subjectId,
          source: input.source,
          topics:
            input.topicIds && input.topicIds.length > 0
              ? { some: { id: { in: input.topicIds } } }
              : undefined,
        },
        cursor: cursor ? { id: cursor } : undefined,
        orderBy: {
          createdAt: "desc",
        },
      })

      let nextCursor: typeof cursor | undefined = undefined
      if (items.length > limit) {
        const nextItem = items.pop()
        nextCursor = nextItem!.id
      }

      return {
        items,
        nextCursor,
      }
    }),

  update: protectedProcedure
    .input(questionInputSchema.extend({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.question.update({
        where: { id: input.id },
        data: {
          ...input,
          topics: {
            set: input.topicIds.map((id) => ({
              id_subjectId: { id, subjectId: input.subjectId },
            })),
          },
        },
      })
    }),

  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.question.delete({ where: { id: input.id } })
    }),
})

```

---

# src/server/api/routers/scraper.ts

```
import { z } from "zod"
import * as cheerio from "cheerio"
import { MathMLToLaTeX } from "mathml-to-latex"
import { QuestionSource, SolutionType } from "@prisma/client"
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc"
import {
  fetchFipi,
  FIPI_ID_CLEANUP_REGEX,
  FIPI_SHOW_PICTURE_Q_REGEX,
  FIPI_URL,
} from "@/server/lib/fipi"

export const scraperRouter = createTRPCRouter({
  scrapeSubjects: protectedProcedure.mutation(async ({ ctx }) => {
    const html = await fetchFipi("/bank/index.php")

    const $ = cheerio.load(html)

    const subjects = $(".projects.active li")
      .map((_, el) => {
        const element = $(el)
        const id = element.attr("id")?.replace("p_", "")
        const name = element.text().trim()
        if (!id || !name) return null
        return { id, name }
      })
      .get()
      .filter(Boolean)

    await ctx.db.subject.createMany({
      data: subjects,
    })

    return { createdCount: subjects.length }
  }),

  scrapeTopics: protectedProcedure
    .input(z.object({ subjectId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const html = await fetchFipi(`/bank/index.php?proj=${input.subjectId}`)

      const $ = cheerio.load(html)

      const scrapedRootTopicNames: string[] = []
      const scrapedSubTopics: {
        id: string
        name: string
        parentName: string
      }[] = []

      let currentParentName: string | null = null
      $('.filter-title:contains("Темы КЭС")')
        .first()
        .next(".dropdown")
        .find(".dropdown-item")
        .each((_, el) => {
          const element = $(el)
          if (element.hasClass("dropdown-header")) {
            currentParentName = element
              .text()
              .trim()
              .replace(FIPI_ID_CLEANUP_REGEX, "")
            scrapedRootTopicNames.push(currentParentName)
          } else {
            const label = element.find("label")
            const id = label.find("input").val() as string
            const name = label.text().trim().replace(FIPI_ID_CLEANUP_REGEX, "")

            if (id && name && currentParentName) {
              scrapedSubTopics.push({ id, name, parentName: currentParentName })
            }
          }
        })

      const existingRootTopics = await ctx.db.topic.findMany({
        where: { subjectId: input.subjectId, parentId: null },
        select: { name: true },
      })
      const existingRootTopicNames = new Set(
        existingRootTopics.map((t) => t.name)
      )

      const newRootTopicsData = scrapedRootTopicNames
        .filter((name) => !existingRootTopicNames.has(name))
        .map((name) => ({ name, subjectId: input.subjectId }))

      if (newRootTopicsData.length > 0) {
        await ctx.db.topic.createMany({ data: newRootTopicsData })
      }

      const allRootTopics = await ctx.db.topic.findMany({
        where: { subjectId: input.subjectId, parentId: null },
      })

      const parentNameToIdMap = new Map<string, string>()
      allRootTopics.forEach((topic) => {
        parentNameToIdMap.set(topic.name, topic.id)
      })

      const subTopicsData = scrapedSubTopics
        .map(({ id, name, parentName }) => {
          const parentId = parentNameToIdMap.get(parentName)
          if (!parentId) return null
          return {
            id,
            name,
            parentId,
            subjectId: input.subjectId,
          }
        })
        .filter((t): t is NonNullable<typeof t> => t !== null)

      let createdSubTopicsCount = 0
      if (subTopicsData.length > 0) {
        const result = await ctx.db.topic.createMany({
          data: subTopicsData,
        })
        createdSubTopicsCount = result.count
      }

      return {
        createdCount: newRootTopicsData.length + createdSubTopicsCount,
      }
    }),

  scrapePage: protectedProcedure
    .input(
      z.object({
        page: z.number().min(1),
        subjectId: z.string(),
      })
    )
    .mutation(async ({ ctx, input: { subjectId, page } }) => {
      const path = `/bank/questions.php?proj=${subjectId}&page=${
        page - 1
      }&pagesize=10&rfsh=${encodeURIComponent(new Date().toString())}`
      const referer = `/bank/index.php?proj=${subjectId}`

      const html = await fetchFipi(path, referer)
      // console.log("\n\n" + html + "\n\n")

      const $ = cheerio.load(
        html.replaceAll("<m:", "<").replaceAll("</m:", "</")
      )

      const parsedQuestions = $(".qblock")
        .map((_, el) => {
          const qblock = $(el)

          const guid = qblock.find('input[name="guid"]').first().val() as string
          const prompt = qblock.find(".hint").first().text().trim()
          const iblock = qblock.next().first()
          const name = iblock
            .find(".id-text .canselect")
            .first()
            .text()
            .trim() as string
          const solutionTypeText = iblock
            .find('td.param-name:contains("Тип ответа:")')
            .first()
            .next("td")
            .text()
            .trim()
          console.log({ guid, prompt, name, solutionTypeText })

          let solutionType: SolutionType
          if (solutionTypeText === "Краткий ответ") {
            solutionType = SolutionType.SHORT
          } else if (solutionTypeText === "Развернутый ответ") {
            solutionType = SolutionType.LONG
          } else {
            return null
          }

          if (!guid || !name) return null

          const bodyParts: string[] = []
          qblock.find("td.cell_0 p.MsoNormal").each((i, p_element) => {
            let currentPart = ""
            $(p_element)
              .contents()
              .each((j, node) => {
                const $node = $(node)
                if (node.type === "text") {
                  currentPart += $node.text()
                } else if (node.type === "tag" && $node.is("math")) {
                  console.log($node.html())
                  let mathML = "<math>" + ($node.html() ?? "") + "</math"
                  const latex = MathMLToLaTeX.convert(mathML)
                  currentPart += `$${latex}$`
                }
              })
            const cleanedPart = currentPart.replace(/\s+/g, " ").trim()
            if (cleanedPart) bodyParts.push(cleanedPart)
          })
          const body = bodyParts.join("\n")

          const attachments: string[] = []
          qblock.find("script").each((_, scriptEl) => {
            const scriptContent = $(scriptEl).html() ?? ""
            const matches = scriptContent.matchAll(FIPI_SHOW_PICTURE_Q_REGEX)
            for (const match of matches) {
              attachments.push(`${FIPI_URL}/${match[1]}`)
            }
          })

          return { id: guid, name, prompt, body, solutionType, attachments }
        })
        .get()
        .filter(Boolean)

      const parsedGuids = parsedQuestions.map((q) => q.id)
      const existingQuestions = await ctx.db.question.findMany({
        where: { id: { in: parsedGuids } },
        select: { id: true },
      })
      const existingIds = new Set(existingQuestions.map((q) => q.id))

      const newQuestions = parsedQuestions.filter((q) => !existingIds.has(q.id))

      for (const question of newQuestions) {
        await ctx.db.question.create({
          data: {
            id: question.id,
            name: question.name,
            prompt: question.prompt,
            body: question.body,
            solutionType: question.solutionType,
            source: QuestionSource.FIPI,
            subjectId,
            creatorId: ctx.session?.user?.id,
            attachments: {
              create: question.attachments.map((url) => ({ url })),
            },
          },
        })
      }
      return { createdCount: newQuestions.length }
    }),
})

```

---

# src/server/api/routers/subject.ts

```
import { z } from "zod"

import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@/server/api/trpc"

export const subjectRouter = createTRPCRouter({
  create: protectedProcedure
    .input(z.object({ name: z.string().min(1) }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.subject.create({
        data: {
          name: input.name,
        },
      })
    }),

  getAll: publicProcedure.query(({ ctx }) => {
    return ctx.db.subject.findMany({
      orderBy: { name: "asc" },
    })
  }),

  getById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(({ ctx, input }) => {
      return ctx.db.subject.findUnique({
        where: { id: input.id },
      })
    }),

  update: protectedProcedure
    .input(z.object({ id: z.string(), name: z.string().min(1) }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.subject.update({
        where: { id: input.id },
        data: { name: input.name },
      })
    }),

  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.subject.delete({
        where: { id: input.id },
      })
    }),
})

```

---

# src/server/api/routers/test.ts

```
import { z } from "zod"

import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc"

const questionEntrySchema = z.object({
  questionId: z.string(),
  order: z.number().int(),
})

export const testRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      z.object({
        name: z.string().min(1),
        subjectId: z.string(),
        questions: z.array(questionEntrySchema).default([]),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.$transaction(async (prisma) => {
        const test = await prisma.test.create({
          data: {
            name: input.name,
            subjectId: input.subjectId,
            creatorId: ctx.session.user.id,
          },
        })

        await prisma.testQuestion.createMany({
          data: input.questions.map((q) => ({
            testId: test.id,
            questionId: q.questionId,
            order: q.order,
          })),
        })

        return test
      })
    }),

  getAllBySubject: protectedProcedure
    .input(z.object({ subjectId: z.string() }))
    .query(({ ctx, input }) => {
      return ctx.db.test.findMany({
        where: { subjectId: input.subjectId, creatorId: ctx.session.user.id },
        include: {
          _count: { select: { questions: true } },
        },
        orderBy: { updatedAt: "desc" },
      })
    }),

  getById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(({ ctx, input }) => {
      return ctx.db.test.findUnique({
        where: { id: input.id },
        include: {
          questions: {
            orderBy: { order: "asc" },
            include: {
              question: true,
            },
          },
        },
      })
    }),

  update: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        name: z.string().min(1),
        subjectId: z.string(),
        questions: z.array(questionEntrySchema).min(1),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.$transaction(async (prisma) => {
        await prisma.testQuestion.deleteMany({
          where: { testId: input.id },
        })

        await prisma.testQuestion.createMany({
          data: input.questions.map((q) => ({
            testId: input.id,
            questionId: q.questionId,
            order: q.order,
          })),
        })

        return prisma.test.update({
          where: { id: input.id },
          data: {
            name: input.name,
            subjectId: input.subjectId,
          },
        })
      })
    }),

  updateQuestions: protectedProcedure
    .input(
      z.object({
        testId: z.string(),
        questionIds: z.array(z.string()),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.$transaction(async (prisma) => {
        await prisma.testQuestion.deleteMany({
          where: { testId: input.testId },
        })

        if (input.questionIds.length > 0) {
          await prisma.testQuestion.createMany({
            data: input.questionIds.map((id, index) => ({
              testId: input.testId,
              questionId: id,
              order: index,
            })),
          })
        }

        return prisma.test.findUnique({ where: { id: input.testId } })
      })
    }),

  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.test.delete({
        where: { id: input.id },
      })
    }),
})

```

---

# src/server/api/routers/topic.ts

```
import { z } from "zod"

import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@/server/api/trpc"

export const topicRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      z.object({
        name: z.string().min(1),
        subjectId: z.string(),
        parentId: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.topic.create({
        data: {
          name: input.name,
          subjectId: input.subjectId,
          parentId: input.parentId,
        },
      })
    }),

  getAllBySubject: publicProcedure
    .input(z.object({ subjectId: z.string() }))
    .query(({ ctx, input }) => {
      return ctx.db.topic.findMany({
        where: { subjectId: input.subjectId },
        orderBy: { name: "asc" },
      })
    }),

  update: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        subjectId: z.string(),
        name: z.string().min(1),
      })
    )
    .mutation(async ({ ctx, input }) => {
      return ctx.db.topic.update({
        where: { id_subjectId: { id: input.id, subjectId: input.subjectId } },
        data: { name: input.name },
      })
    }),

  delete: protectedProcedure
    .input(z.object({ id: z.string(), subjectId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      return ctx.db.topic.delete({
        where: { id_subjectId: { id: input.id, subjectId: input.subjectId } },
      })
    }),
})

```

---

# src/server/api/trpc.ts

```
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */

import { initTRPC, TRPCError } from "@trpc/server"
import { type CreateNextContextOptions } from "@trpc/server/adapters/next"
import { type Session } from "next-auth"
import superjson from "superjson"
import { ZodError } from "zod"

import { auth } from "@/server/auth"
import { db } from "@/server/db"

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 */

interface CreateContextOptions {
  session: Session | null
}

/**
 * This helper generates the "internals" for a tRPC context. If you need to use it, you can export
 * it from here.
 *
 * Examples of things you may need it for:
 * - testing, so we don't have to mock Next.js' req/res
 * - tRPC's `createSSGHelpers`, where we don't have req/res
 *
 * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts
 */
const createInnerTRPCContext = (opts: CreateContextOptions) => {
  return {
    session: opts.session,
    db,
  }
}

/**
 * This is the actual context you will use in your router. It will be used to process every request
 * that goes through your tRPC endpoint.
 *
 * @see https://trpc.io/docs/context
 */
export const createTRPCContext = async (opts: CreateNextContextOptions) => {
  const { req, res } = opts

  // Get the session from the server using the getServerSession wrapper function
  const session = await auth(req, res)

  return createInnerTRPCContext({
    session,
  })
}

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */

const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    }
  },
})

/**
 * Create a server-side caller.
 *
 * @see https://trpc.io/docs/server/server-side-calls
 */
export const createCallerFactory = t.createCallerFactory

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router

/**
 * Middleware for timing procedure execution and adding an artificial delay in development.
 *
 * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating
 * network latency that would occur in production but not in local development.
 */
const timingMiddleware = t.middleware(async ({ next, path }) => {
  const start = Date.now()

  if (t._config.isDev) {
    // artificial delay in dev
    const waitMs = Math.floor(Math.random() * 400) + 100
    await new Promise((resolve) => setTimeout(resolve, waitMs))
  }

  const result = await next()

  const end = Date.now()
  console.log(`[TRPC] ${path} took ${end - start}ms to execute`)

  return result
})

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure.use(timingMiddleware)

/**
 * Protected (authenticated) procedure
 *
 * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies
 * the session is valid and guarantees `ctx.session.user` is not null.
 *
 * @see https://trpc.io/docs/procedures
 */
export const protectedProcedure = t.procedure
  .use(timingMiddleware)
  .use(({ ctx, next }) => {
    if (!ctx.session?.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" })
    }
    return next({
      ctx: {
        // infers the `session` as non-nullable
        session: { ...ctx.session, user: ctx.session.user },
      },
    })
  })

```

---

# src/server/auth/index.ts

```
import NextAuth from "next-auth"
import { cache } from "react"

import authOptions from "./options"

const { auth: uncachedAuth, handlers, signIn, signOut } = NextAuth(authOptions)

const auth = cache(uncachedAuth)

export { auth, handlers, signIn, signOut }

```

---

# src/server/auth/options.ts

```
import { type NextAuthConfig } from "next-auth"
import CredentialsProvider from "next-auth/providers/credentials"
import bcrypt from "bcryptjs"
import { db } from "@/server/db"

const authOptions: NextAuthConfig = {
  session: {
    strategy: "jwt",
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        name: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials || !credentials.name || !credentials.password) {
          throw new Error("No credentials provided.")
        }

        const user = await db?.user.findFirst({
          where: { name: credentials.name },
        })

        if (!user) {
          throw new Error("No user found!")
        }

        const isValid = await bcrypt.compare(
          credentials.password as string,
          user.password as string
        )

        if (!isValid) {
          throw new Error("Could not log you in!")
        }

        return { id: user.id, name: user.name }
      },
    }),
  ],
  callbacks: {
    jwt: async ({ token, user }) => {
      if (user) {
        token.id = user.id
      }
      return token
    },
    session: async ({ session, token }) => {
      if (token && session.user) {
        session.user.id = token.id as string
      }
      return session
    },
  },
  pages: {
    signIn: "/sign-in",
  },
}

export default authOptions

```

---

# src/server/db.ts

```
import { PrismaClient } from "@prisma/client";

import { env } from "@/env";

const createPrismaClient = () =>
  new PrismaClient({
    log:
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;

```

---

# src/server/lib/fipi.ts

```
import { Agent, fetch } from "undici"
import { env } from "@/env"
import tls from "node:tls"

const FIPI_BASE_URL = "https://ege.fipi.ru"

export const fetchFipi = async (path: string, referer?: string) => {
  const fipiAgent = new Agent({
    connect: {
      ca: [...tls.rootCertificates, env.FIPI_INTERMEDIATE_CERT],
    },
  })

  console.log(`${FIPI_BASE_URL}${path}`)

  const response = await fetch(`${FIPI_BASE_URL}${path}`, {
    headers: {
      accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
      "accept-language": "en-US,en;q=0.9",
      "user-agent":
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
      "sec-ch-ua": '"Chromium";v="139", "Not;A=Brand";v="99"',
      "sec-ch-ua-mobile": "?0",
      "sec-ch-ua-platform": '"Linux"',
      "sec-fetch-dest": "iframe",
      "sec-fetch-mode": "navigate",
      "sec-fetch-site": "same-origin",
      "sec-fetch-user": "?1",
      "upgrade-insecure-requests": "1",
      cookie:
        "PHPSESSID=v0ogeg7m0j195tgtv1aht55f30; md_auto=qprint; session-cookie=1861c2420857576bcb198c4fd00b084571a6aec2cad1efe576ea9ee289778a292b0835dd0a03e651ff38f9dafaa0b0ad; md_auto=qprint",
      Referer: referer ? `${FIPI_BASE_URL}${referer}` : "",
    },
    method: "GET",
    dispatcher: fipiAgent,
  })

  if (!response.ok) throw new Error("Failed to fetch " + path)

  const buffer = await response.arrayBuffer()
  const decoder = new TextDecoder("windows-1251")
  const html = decoder.decode(buffer)

  return html
}

export const FIPI_SHOW_PICTURE_Q_REGEX = /ShowPictureQ\('(.*?)'\)/g
export const FIPI_ID_CLEANUP_REGEX = /^\s*\d+(\.\d+)*\s*/
export const FIPI_URL = FIPI_BASE_URL

```

---

# src/styles/dark.css

```
@layer base {
  [data-theme="dark"] {
    --color-*: initial;

    /* Background Colors */
    --background-color-primary: oklch(0.208 0.042 265.755); /* slate-900 */
    --background-color-paper: oklch(0.279 0.041 260.031); /* slate-800 */
    --background-color-input: oklch(0.279 0.041 260.031); /* slate-800 */
    --background-color-accent: oklch(0.585 0.233 277.117); /* indigo-500 */
    --background-color-accent-highlight: oklch(0.673 0.182 276.935); /* indigo-400 */
    --background-color-danger: oklch(0.637 0.237 25.331); /* red-500 */
    --background-color-danger-highlight: oklch(0.704 0.191 22.216); /* red-400 */
    --background-color-muted: oklch(0.372 0.044 257.287); /* slate-700 */
    --background-color-muted-highlight: oklch(0.446 0.043 257.281); /* slate-600 */

    /* Text Colors */
    --text-color-primary: oklch(0.929 0.013 255.508); /* slate-200 */
    --text-color-secondary: oklch(0.704 0.04 256.788); /* slate-400 */
    --text-color-on-accent: #fff; /* white */
    --text-color-danger: oklch(0.936 0.032 17.717); /* red-100 */
    --text-color-muted: oklch(0.554 0.046 257.417); /* slate-500 */

    /* Border & Ring Colors */
    --border-color-primary: oklch(0.372 0.044 257.287); /* slate-700 */
    --border-color-input: oklch(0.446 0.043 257.281); /* slate-600 */
    --ring-color-accent: oklch(0.585 0.233 277.117 / 0.5); /* indigo-500 with opacity */

    /* Shadow Colors */
    --shadow-color: 0 0 0; /* black RGB */
  }

  body {
    background-color: var(--background-color-primary);
    color: var(--text-color-primary);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}
```

---

# src/styles/globals.css

```
@import "tailwindcss";

@theme {
  /* Light Theme (Default) */
  --color-*: initial;

  /* Background Colors */
  --background-color-primary: oklch(97% 0.001 106.424); /* stone-100 */
  --background-color-secondary: oklch(98.5% 0.001 106.423); /* stone-50 */
  --background-color-paper: #fff; /* white */
  --background-color-input: #fff; /* white */
  --background-color-input-highlight: oklch(98.5% 0.001 106.423); /* blue-50 */
  --background-color-accent: oklch(0.623 0.214 259.815); /* blue-500 */
  --background-color-accent-highlight: oklch(0.707 0.165 254.624); /* blue-400 */
  --background-color-danger: oklch(0.637 0.237 25.331); /* red-500 */
  --background-color-danger-highlight: oklch(0.704 0.191 22.216); /* red-400 */
  --background-color-muted: oklch(0.928 0.006 264.531); /* gray-200 */
  --background-color-muted-highlight: oklch(0.872 0.01 258.338); /* gray-300 */

  --background-color-text-primary: oklch(0.208 0.042 265.755); /* slate-900 */
  --background-color-text-primary-highlight: oklch(37.2% 0.044 257.287); /* slate-700 */

  /* Text Colors */
  --text-color-primary: oklch(0.208 0.042 265.755); /* slate-900 */
  --text-color-primary-highlight: oklch(37.2% 0.044 257.287); /* slate-700 */
  --text-color-secondary: oklch(0.446 0.043 257.281); /* slate-600 */
  --text-color-on-accent: #fff; /* white */
  --text-color-danger: oklch(0.936 0.032 17.717); /* red-100 */
  --text-color-muted: oklch(0.554 0.046 257.417); /* slate-500 */

  /* Border & Ring Colors */
  --border-color-primary: oklch(0.929 0.013 255.508); /* slate-200 */
  --border-color-input: oklch(0.869 0.022 252.894); /* slate-300 */
  --ring-color-accent: oklch(62.3% 0.214 259.815 / 0.5); /* blue-500/50 */

  /* Shadow Colors */
  --shadow-color-primary: 15 23 42; /* slate-900 RGB */

  /* Fonts */
  --font-sans:
    var(--font-geist-sans), ui-sans-serif, system-ui, sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}

body {
  background-color: var(--background-color-primary);
  color: var(--text-color-primary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

```

---

# src/styles/index.ts

```
import type { ClassValue } from "clsx"
import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export const cn = (...inputs: ClassValue[]) => {
  return twMerge(clsx(inputs))
}

```

---

# src/types/next-auth.d.ts

```
import { type DefaultSession } from "next-auth"
import { type User } from "@prisma/client"

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      name: string
      permissions: User["permissions"]
    } & DefaultSession["user"]
  }
}

```

---

# src/ui/Box.tsx

```
import { cn } from "@/styles"
import React from "react"

type BoxProps = {
  children: React.ReactNode
  className?: string
}

export function Box({ children, className = "" }: BoxProps) {
  return <div className={cn(className)}>{children}</div>
}

```

---

# src/ui/Button.tsx

```
import { Button as HeadlessButton } from "@headlessui/react"
import { cva, type VariantProps } from "class-variance-authority"
import React, { forwardRef } from "react"

import { cn } from "@/styles"

// TODO fix disabled cursor
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-accent focus:ring-offset-2 cursor-pointer data-disabled:cursor-pointer data-disabled:pointer-events-none data-disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "bg-accent text-on-accent hover:bg-accent-highlight",
        secondary: "bg-input text-primary hover:bg-input-highlight",
        danger: "bg-danger text-on-accent hover:bg-danger-highlight",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ComponentProps<typeof HeadlessButton>,
    VariantProps<typeof buttonVariants> {}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <HeadlessButton
        ref={ref}
        className={cn(buttonVariants({ variant, size, className }))}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

---

# src/ui/Checkbox.tsx

```
import { Checkbox as HeadlessCheckbox, Field, Label } from "@headlessui/react"
import { Check } from "lucide-react"
import React from "react"

import { cn } from "@/styles"

type CheckboxProps = {
  checked: boolean
  onChange: (checked: boolean) => void
  label: string
  className?: string
}

export function Checkbox({
  checked,
  onChange,
  label,
  className,
}: CheckboxProps) {
  return (
    <Field className={cn("flex items-center gap-2", className)}>
      <HeadlessCheckbox
        checked={checked}
        onChange={onChange}
        className="group flex h-4 w-4 items-center justify-center rounded border border-input bg-input focus:outline-none focus:ring-2 focus:ring-accent"
      >
        <Check className="hidden h-3 w-3 text-on-accent group-data-checked:block" />
      </HeadlessCheckbox>
      <Label className="text-sm font-medium text-primary">{label}</Label>
    </Field>
  )
}

```

---

# src/ui/Container.tsx

```
import { cn } from "@/styles"
import React from "react"

type ContainerProps = {
  children: React.ReactNode
  className?: string
}

export function Container({ children, className = "" }: ContainerProps) {
  return (
    <div className={cn("mx-auto w-full h-full md:container", className)}>
      {children}
    </div>
  )
}

```

---

# src/ui/Dialog.tsx

```
import {
  Dialog as HeadlessDialog,
  DialogPanel,
  DialogTitle,
  Transition,
  TransitionChild,
} from "@headlessui/react"
import { X } from "lucide-react"
import React, { Fragment } from "react"

import { cn } from "@/styles"

type DialogProps = {
  isOpen: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
  className?: string
}

export function Dialog({
  isOpen,
  onClose,
  title,
  children,
  className,
}: DialogProps) {
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <HeadlessDialog as="div" className="relative z-50" onClose={onClose}>
        <TransitionChild
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black/30" />
        </TransitionChild>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <TransitionChild
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <DialogPanel
                className={cn(
                  "w-full transform overflow-hidden rounded-2xl bg-paper p-6 text-left align-middle shadow-xl transition-all",
                  className
                )}
              >
                <DialogTitle
                  as="h3"
                  className="flex items-center justify-between text-lg font-medium leading-6 text-primary"
                >
                  {title}
                  <button
                    onClick={onClose}
                    className="rounded-full p-1 text-primary hover:bg-secondary cursor-pointer"
                  >
                    <X className="h-5 w-5" />
                  </button>
                </DialogTitle>
                <div className="mt-4">{children}</div>
              </DialogPanel>
            </TransitionChild>
          </div>
        </div>
      </HeadlessDialog>
    </Transition>
  )
}

export function DialogFooter({
  children,
  className,
}: {
  children: React.ReactNode
  className?: string
}) {
  return (
    <div className={cn("mt-6 flex justify-end gap-2", className)}>
      {children}
    </div>
  )
}

```

---

# src/ui/Input.tsx

```
import { Input as HeadlessInput } from "@headlessui/react"
import React, { forwardRef } from "react"

import { cn } from "@/styles"

type InputProps = React.ComponentPropsWithoutRef<"input">

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className, ...props }, ref) => {
    return (
      <HeadlessInput
        ref={ref}
        className={cn(
          "w-full rounded-md border border-input bg-input px-3 py-2 text-primary placeholder:text-muted focus:outline-none focus:ring-2 focus:ring-accent data-disabled:cursor-not-allowed data-disabled:opacity-50",
          className
        )}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

```

---

# src/ui/Listbox.tsx

```
import {
  Listbox as HeadlessListbox,
  ListboxButton,
  ListboxOption,
  ListboxOptions,
} from "@headlessui/react"
import { Check, ChevronsUpDown } from "lucide-react"
import React from "react"

import { cn } from "@/styles"

export type ListboxOptionType<T> = {
  value: T
  label: string
}

type BaseProps<T> = {
  options: ListboxOptionType<T>[]
  placeholder?: string
  className?: string
}

type SingleSelectProps<T> = {
  multiple?: false
  value: ListboxOptionType<T> | null
  onChange: (value: ListboxOptionType<T>) => void
}

type MultiSelectProps<T> = {
  multiple: true
  value: ListboxOptionType<T>[]
  onChange: (value: ListboxOptionType<T>[]) => void
}

type ListboxProps<T> = BaseProps<T> &
  (SingleSelectProps<T> | MultiSelectProps<T>)

function ListboxComponent<T extends string | number>(props: ListboxProps<T>) {
  const { options, value, onChange, placeholder, multiple, className } = props

  const getButtonText = () => {
    if (multiple) {
      if (value && value.length > 0) {
        return value.map((v) => v.label).join(", ")
      }
    } else {
      if (value) {
        return value.label
      }
    }
    return placeholder
  }

  return (
    <HeadlessListbox
      value={value}
      onChange={onChange as any}
      multiple={multiple}
    >
      <div className={cn("relative", className)}>
        <ListboxButton className="relative w-full cursor-default rounded-md border border-input bg-input py-2 pl-3 pr-10 text-left text-primary focus:outline-none focus:ring-2 focus:ring-accent">
          <span className="block truncate">{getButtonText()}</span>
          <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
            <ChevronsUpDown className="h-5 w-5 text-secondary" />
          </span>
        </ListboxButton>
        <ListboxOptions className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md border border-primary bg-paper py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
          {options.map((option) => (
            <ListboxOption
              key={String(option.value)}
              value={option}
              className="group relative cursor-default select-none py-2 pl-10 pr-4 text-secondary data-focus:bg-muted-highlight data-focus:text-primary"
            >
              <span className="block truncate font-normal group-data-selected:font-semibold">
                {option.label}
              </span>
              <span className="absolute inset-y-0 left-0 hidden items-center pl-3 text-accent group-data-selected:flex">
                <Check className="h-5 w-5" />
              </span>
            </ListboxOption>
          ))}
        </ListboxOptions>
      </div>
    </HeadlessListbox>
  )
}

export const Listbox = React.memo(ListboxComponent) as typeof ListboxComponent

```

---

# src/ui/Paper.tsx

```
import { cn } from "@/styles"
import React from "react"

type PaperProps = {
  children: React.ReactNode
  className?: string
}

export function Paper({ children, className = "" }: PaperProps) {
  return (
    <div
      className={cn(
        "rounded-xl bg-paper p-4 shadow-md shadow-primary sm:p-6",
        className
      )}
    >
      {children}
    </div>
  )
}

```

---

# src/ui/Radio.tsx

```
import {
  Description,
  Field,
  Label,
  Radio,
  RadioGroup as HeadlessRadioGroup,
} from "@headlessui/react"
import { Check } from "lucide-react"
import React from "react"

import { cn } from "@/styles"
import { buttonVariants } from "./Button"

export type RadioOption<T> = {
  value: T
  label: string
  description?: string
}

type RadioGroupProps<T> = {
  options: RadioOption<T>[]
  value: T | null
  onChange: (value: T) => void
  className?: string
  variant?: "default" | "button"
}

function RadioGroupComponent<T extends string | number>({
  options,
  value,
  onChange,
  className,
  variant = "default",
}: RadioGroupProps<T>) {
  return (
    <HeadlessRadioGroup
      value={value}
      onChange={onChange}
      className={cn(
        variant === "default" ? "space-y-2" : "flex flex-wrap gap-2",
        className
      )}
    >
      {options.map((option) =>
        variant === "button" ? (
          <Radio
            key={String(option.value)}
            value={option.value}
            className={cn(
              buttonVariants({ size: "sm" }),
              "cursor-pointer focus:outline-none data-checked:cursor-default",
              "bg-input text-primary hover:bg-input-highlight",
              "data-checked:bg-accent data-checked:text-on-accent data-checked:hover:bg-accent-highlight"
            )}
          >
            {option.label}
          </Radio>
        ) : (
          <Field
            key={String(option.value)}
            className="group flex items-center gap-2"
          >
            <Radio
              value={option.value}
              className="group/radio peer/radio flex size-4 items-center justify-center rounded-full border border-primary bg-white data-checked:border-0 data-checked:bg-text-primary transition-colors cursor-pointer data-checked:cursor-default"
            >
              <Check className="h-3 w-3 fill-accent text-on-accent opacity-0 group-data-checked/radio:opacity-100 stroke-3 transition-opacity" />
            </Radio>
            <Label className="cursor-pointer peer-data-checked/radio:cursor-default group-hover:text-primary-highlight peer-data-checked/radio:group-hover:text-primary">
              {option.label}
            </Label>
          </Field>
        )
      )}
    </HeadlessRadioGroup>
  )
}

export const RadioGroup = React.memo(RadioGroupComponent) as <
  T extends string | number,
>(
  props: RadioGroupProps<T>
) => React.ReactElement

```

---

# src/ui/Row.tsx

```
import { cn } from "@/styles"
import React from "react"

type RowProps = {
  children: React.ReactNode
  className?: string
}

export function Row({ children, className = "" }: RowProps) {
  return (
    <div className={cn("flex flex-row items-center", className)}>
      {children}
    </div>
  )
}

```

---

# src/ui/Stack.tsx

```
import { cn } from "@/styles"
import React from "react"

type StackProps = {
  children: React.ReactNode
  className?: string
}

export function Stack({ children, className = "" }: StackProps) {
  return <div className={cn("flex flex-col", className)}>{children}</div>
}

```

---

# src/ui/Tabs.tsx

```
import { Tab, TabGroup, TabList, TabPanel, TabPanels } from "@headlessui/react"
import React from "react"

export type TabItem = {
  id: string | number
  label: string
  content: React.ReactNode
}

type TabsProps = {
  items: TabItem[]
  className?: string
}

export function Tabs({ items, className }: TabsProps) {
  return (
    <TabGroup as={React.Fragment}>
      <TabList className="flex gap-4 border-b border-primary">
        {items.map((item) => (
          <Tab
            key={item.id}
            className="rounded-t-lg px-4 py-2 text-sm font-medium text-secondary outline-none data-selected:border-b-2 data-selected:border-accent data-selected:text-primary data-focus:ring-2 data-focus:ring-accent"
          >
            {item.label}
          </Tab>
        ))}
      </TabList>
      <TabPanels className="mt-4">
        {items.map((item) => (
          <TabPanel key={item.id}>{item.content}</TabPanel>
        ))}
      </TabPanels>
    </TabGroup>
  )
}

```

---

# src/ui/index.ts

```
export * from "./Container"
export * from "./Stack"
export * from "./Row"
export * from "./Paper"
export * from "./Input"
export * from "./Checkbox"
export * from "./Listbox"
export * from "./Button"
export * from "./Dialog"
export * from "./Tabs"
export * from "./Radio"
export * from "./Box"

```

---

# src/utils/api.ts

```
/**
 * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which
 * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.
 *
 * We also create a few inference helpers for input and output types.
 */
import { httpBatchLink, loggerLink } from "@trpc/client"
import { createTRPCNext } from "@trpc/next"
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server"
import superjson from "superjson"

import { type AppRouter } from "@/server/api/root"

const getBaseUrl = () => {
  if (typeof window !== "undefined") return "" // browser should use relative url
  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}` // SSR should use vercel url
  return `http://localhost:${process.env.PORT ?? 3000}` // dev SSR should use localhost
}

/** A set of type-safe react-query hooks for your tRPC API. */
export const api = createTRPCNext<AppRouter>({
  config() {
    return {
      /**
       * Links used to determine request flow from client to server.
       *
       * @see https://trpc.io/docs/links
       */
      links: [
        loggerLink({
          enabled: (opts) =>
            process.env.NODE_ENV === "development" ||
            (opts.direction === "down" && opts.result instanceof Error),
        }),
        httpBatchLink({
          /**
           * Transformer used for data de-serialization from the server.
           *
           * @see https://trpc.io/docs/data-transformers
           */
          transformer: superjson,
          url: `${getBaseUrl()}/api/trpc`,
        }),
      ],
    }
  },
  /**
   * Whether tRPC should await queries when server rendering pages.
   *
   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false
   */
  ssr: false,
  transformer: superjson,
})

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>

```

---

# src/utils/i18n/index.ts

```
export const t = (key: string) => {
  return key
}

```

---

# tsconfig.json

```
{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,

    /* Bundled projects */
    "lib": ["dom", "dom.iterable", "ES2022"],
    "noEmit": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "preserve",
    "plugins": [{ "name": "next" }],
    "incremental": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.js",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}

```

---

# update-fipi-cert.sh

```
#!/bin/sh

# This script automates fetching the missing intermediate certificate
# for ege.fipi.ru, which is misconfigured and doesn't send the full trust chain.
# It then updates the ./.env file with this certificate in the correct format.

# Exit immediately if any command fails
set -e

# --- Configuration ---
HOST="ege.fipi.ru"
PORT="443"
ENV_VAR_NAME="FIPI_INTERMEDIATE_CERT"
ENV_FILE="./.env"
# ---------------------

echo "Starting FIPI certificate update for $HOST..."

# 1. Connect to the server, get its leaf cert, parse it to find the "CA Issuers" URL.
#    This URL points to the intermediate certificate we need.
echo "Fetching certificate from $HOST to find its issuer..."
CERT_URL=$(openssl s_client -connect ${HOST}:${PORT} 2>/dev/null </dev/null | \
  openssl x509 -text -noout | \
  grep -A 1 "Authority Information Access" | \
  grep "CA Issuers" | \
  sed 's/.*CA Issuers - URI:\(.*\)/\1/')

if [ -z "$CERT_URL" ]; then
  echo "Error: Could not find 'CA Issuers - URI' in the certificate."
  echo "The server's certificate may have changed. Please check manually."
  exit 1
fi

echo "Found intermediate certificate URL: $CERT_URL"

# 2. Download that certificate. It's in binary DER format.
#    Pipe it directly to openssl to convert it from DER to text PEM format.
echo "Downloading and converting intermediate certificate from DER to PEM..."
CERT_PEM=$(curl -sL "$CERT_URL" | openssl x509 -inform DER -outform PEM)

if [ -z "$CERT_PEM" ]; then
  echo "Error: Failed to download or convert the certificate."
  exit 1
fi

# 3. Convert the multi-line PEM text into a single line with literal '\n' characters,
#    suitable for an environment variable.
echo "Formatting certificate for .env file..."
ENV_VALUE=$(echo "$CERT_PEM" | awk '{printf "%s\\n", $0}')

# 4. Create the final line to be written to the .env file.
FINAL_LINE="${ENV_VAR_NAME}=\"${ENV_VALUE}\""

# 5. Ensure the .env file exists so we can write to it.
touch "$ENV_FILE"

# 6. Remove any existing line for this variable from .env.
#    This uses a portable sed command that works on both Linux (GNU) and macOS (BSD).
#    It creates a backup file (.env.bak) and then immediately deletes it on success.
echo "Removing old $ENV_VAR_NAME from $ENV_FILE (if it exists)..."
sed -i.bak "/^${ENV_VAR_NAME}=/d" "$ENV_FILE" && rm "${ENV_FILE}.bak"

# 7. Append the new, complete line to the end of the .env file.
echo "Appending new $ENV_VAR_NAME to $ENV_FILE..."
echo "$FINAL_LINE" >> "$ENV_FILE"
echo "$FINAL_LINE"

echo "✅ Success! FIPI Intermediate Certificate has been updated in $ENV_FILE."
```
